
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>KafkaProducer Quick Start</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.0/css/bootstrap.min.css" integrity="sha384-SI27wrMjH3ZZ89r4o+fGIJtnzkAnFs3E4qz9DIYioCQ5l9Rd/7UAa8DHcaL8jkWt" crossorigin="anonymous">
    <style>
      pre { background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; padding: 0.6em 1em; }
      h1,h2 { margin-top: 1em; }
      div.navbar { padding: 8px 0; }
      div.toc { float: right; }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 id="kafkaproducer-quick-start"><a class="toclink" href="#kafkaproducer-quick-start">KafkaProducer Quick Start</a></h1>
<p>Generally speaking, The <code>Modern C++ Kafka API</code> is quite similar to the <a href="https://kafka.apache.org/10/javadoc/org/apache/kafka/clients/producer/KafkaProducer.html">Kafka Java's API</a>.</p>
<p>We'd recommend users to cross-reference them, --especially the examples.</p>
<h2 id="kafkaproducer"><a class="toclink" href="#kafkaproducer">KafkaProducer</a></h2>
<ul>
<li>The <code>send</code> is an unblock operation, and the result (including errors) could only be got from the delivery callback.</li>
</ul>
<h3 id="example"><a class="toclink" href="#example">Example</a></h3>
<div class="codehilite"><pre><span></span>        <span class="k">using</span> <span class="k">namespace</span> <span class="n">kafka</span><span class="o">::</span><span class="n">clients</span><span class="p">;</span>



        <span class="c1">// Create configuration object</span>

        <span class="n">kafka</span><span class="o">::</span><span class="n">Properties</span> <span class="n">props</span> <span class="p">({</span>

            <span class="p">{</span><span class="s">&quot;bootstrap.servers&quot;</span><span class="p">,</span>  <span class="n">brokers</span><span class="p">},</span>

            <span class="p">{</span><span class="s">&quot;enable.idempotence&quot;</span><span class="p">,</span> <span class="s">&quot;true&quot;</span><span class="p">},</span>

        <span class="p">});</span>



        <span class="c1">// Create a producer instance</span>

        <span class="n">KafkaProducer</span> <span class="nf">producer</span><span class="p">(</span><span class="n">props</span><span class="p">);</span>



        <span class="c1">// Read messages from stdin and produce to the broker</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;% Type message value and hit enter to produce message. (empty line to quit)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>



        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">line</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span>

             <span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">,</span> <span class="o">*</span><span class="n">line</span><span class="p">);</span>

             <span class="n">line</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>

            <span class="c1">// The ProducerRecord doesn&#39;t own `line`, it is just a thin wrapper</span>

            <span class="k">auto</span> <span class="n">record</span> <span class="o">=</span> <span class="n">producer</span><span class="o">::</span><span class="n">ProducerRecord</span><span class="p">(</span><span class="n">topic</span><span class="p">,</span>

                                                   <span class="n">kafka</span><span class="o">::</span><span class="n">NullKey</span><span class="p">,</span>

                                                   <span class="n">kafka</span><span class="o">::</span><span class="n">Value</span><span class="p">(</span><span class="n">line</span><span class="o">-&gt;</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">line</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()));</span>



            <span class="c1">// Send the message</span>

            <span class="n">producer</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">record</span><span class="p">,</span>

                          <span class="c1">// The delivery report handler</span>

                          <span class="c1">// Note: Here we capture the shared_pointer of `line`,</span>

                          <span class="c1">//       which holds the content for `record.value()`.</span>

                          <span class="c1">//       It makes sure the memory block is valid until the lambda finishes.</span>

                          <span class="p">[</span><span class="n">line</span><span class="p">](</span><span class="k">const</span> <span class="n">producer</span><span class="o">::</span><span class="n">RecordMetadata</span><span class="o">&amp;</span> <span class="n">metadata</span><span class="p">,</span> <span class="k">const</span> <span class="n">kafka</span><span class="o">::</span><span class="n">Error</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>

                              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>

                                  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;% Message delivered: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">metadata</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

                              <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

                                  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;% Message delivery failed: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">error</span><span class="p">.</span><span class="n">message</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

                              <span class="p">}</span>

                          <span class="p">});</span>



            <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span> <span class="k">break</span><span class="p">;</span>

        <span class="p">}</span>



        <span class="c1">// producer.close(); // No explicit close is needed, RAII will take care of it</span>
</pre></div>

<ul>
<li>
<p>User must guarantee the memory block for <code>ProducerRecord</code>'s <code>key</code> is valid until being <code>send</code>.</p>
</li>
<li>
<p>By default, the memory block for <code>ProducerRecord</code>'s <code>value</code> must be valid until the delivery callback is called; Otherwise, the <code>send</code> should be with option <code>KafkaProducer::SendOption::ToCopyRecordValue</code>.</p>
</li>
<li>
<p>It's guaranteed that the delivery callback would be triggered anyway after <code>send</code>, -- a producer would even be waiting for it before <code>close</code>. So, it's a good way to release these memory resources in the <code>Producer::Callback</code> function.</p>
</li>
</ul>
<h2 id="kafkaproducer-with-kafkaclientskafkaclienteventspollingoption"><a class="toclink" href="#kafkaproducer-with-kafkaclientskafkaclienteventspollingoption"><code>KafkaProducer</code> with <code>kafka::clients::KafkaClient::EventsPollingOption</code></a></h2>
<p>While we construct a <code>KafkaProducer</code> with <code>kafka::clients::KafkaClient::EventsPollingOption::Auto</code> (the default option), an internal thread would be created for <code>MessageDelivery</code> callbacks handling.</p>
<p>This might not be what you want, since then you have to use 2 different threads to send the messages and handle the <code>MessageDelivery</code> responses.</p>
<p>Here we have another choice, -- using <code>kafka::clients::KafkaClient::EventsPollingOption::Manual</code>, thus the <code>MessageDelivery</code> callbacks would be called within member function <code>pollEvents()</code>.</p>
<ul>
<li>Note, if you constructed the <code>KafkaProducer</code> with <code>EventsPollingOption::Manual</code>, the <code>send()</code> would be an <code>unblocked</code> operation.</li>
</ul>
<p>I.e, once the <code>message buffering queue</code> becomes full, the <code>send()</code> operation would throw an exception (or return an <code>error code</code> with the input reference parameter), -- instead of blocking there.</p>
<p>This makes sense, since you might want to call <code>pollEvents()</code> later, thus delivery-callback could be called for some messages (which could then be removed from the <code>message buffering queue</code>).</p>
<h3 id="example_1"><a class="toclink" href="#example_1">Example</a></h3>
<div class="codehilite"><pre><span></span>    <span class="k">using</span> <span class="k">namespace</span> <span class="n">kafka</span><span class="o">::</span><span class="n">clients</span><span class="p">;</span>



    <span class="n">KafkaProducer</span> <span class="nf">producer</span><span class="p">(</span><span class="n">props</span><span class="p">,</span> <span class="n">KafkaClient</span><span class="o">::</span><span class="n">EventsPollingOption</span><span class="o">::</span><span class="n">Manual</span><span class="p">);</span>



    <span class="c1">// Prepare &quot;msgsToBeSent&quot;</span>

    <span class="k">auto</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Value</span><span class="o">&gt;&gt;</span> <span class="n">msgsToBeSent</span> <span class="o">=</span> <span class="p">...;</span>



    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">msg</span> <span class="p">:</span> <span class="n">msgsToBeSent</span><span class="p">)</span> <span class="p">{</span>

        <span class="k">auto</span> <span class="n">record</span> <span class="o">=</span> <span class="n">producer</span><span class="o">::</span><span class="n">ProducerRecord</span><span class="p">(</span><span class="n">topic</span><span class="p">,</span> <span class="n">partition</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">second</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>

        <span class="n">kafka</span><span class="o">::</span><span class="n">Error</span> <span class="n">sendError</span><span class="p">;</span>

        <span class="n">producer</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">sendError</span><span class="p">,</span>

                      <span class="n">record</span><span class="p">,</span>

                      <span class="c1">// Ack callback</span>

                      <span class="p">[</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">](</span><span class="k">const</span> <span class="n">producer</span><span class="o">::</span><span class="n">RecordMetadata</span><span class="o">&amp;</span> <span class="n">metadata</span><span class="p">,</span> <span class="k">const</span> <span class="n">kafka</span><span class="o">::</span><span class="n">Error</span><span class="o">&amp;</span> <span class="n">deliveryError</span><span class="p">)</span> <span class="p">{</span>

                           <span class="c1">// the message could be identified by `metadata.recordId()`</span>

                           <span class="k">if</span> <span class="p">(</span><span class="n">deliveryError</span><span class="p">)</span>  <span class="p">{</span>

                               <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;% Message delivery failed: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">deliveryError</span><span class="p">.</span><span class="n">message</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

                           <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

                               <span class="n">msgsToBeSend</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">recordId</span><span class="p">());</span> <span class="c1">// Quite safe here</span>

                           <span class="p">}</span>

                       <span class="p">});</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">sendError</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

    <span class="p">}</span>



    <span class="c1">// Here we call the `MessageDelivery` callbacks</span>

    <span class="c1">// Note, we can only do this while the producer was constructed with `EventsPollingOption::MANUAL`.</span>

    <span class="n">producer</span><span class="p">.</span><span class="n">pollEvents</span><span class="p">();</span>
</pre></div>

<h2 id="headers-in-producerrecord"><a class="toclink" href="#headers-in-producerrecord">Headers in ProducerRecord</a></h2>
<ul>
<li>
<p>A <code>ProducerRecord</code> could take extra information with <code>headers</code>.</p>
<ul>
<li>Note, the <code>header</code> within <code>headers</code> contains the pointer of the memory block for its <code>value</code>. The memory block MUST be valid until the <code>ProducerRecord</code> is read by <code>producer.send()</code>.</li>
</ul>
</li>
</ul>
<h3 id="example_2"><a class="toclink" href="#example_2">Example</a></h3>
<div class="codehilite"><pre><span></span>    <span class="k">using</span> <span class="k">namespace</span> <span class="n">kafka</span><span class="o">::</span><span class="n">clients</span><span class="p">;</span>



    <span class="n">kafak</span><span class="o">::</span><span class="n">KafkaProducer</span> <span class="n">producer</span><span class="p">(</span><span class="n">props</span><span class="p">);</span>



    <span class="k">auto</span> <span class="n">record</span> <span class="o">=</span> <span class="n">producer</span><span class="o">::</span><span class="n">ProducerRecord</span><span class="p">(</span><span class="n">topic</span><span class="p">,</span> <span class="n">partition</span><span class="p">,</span> <span class="n">Key</span><span class="p">(),</span> <span class="n">Value</span><span class="p">());</span>



    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">msg</span> <span class="p">:</span> <span class="n">msgsToBeSent</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// Prepare record headers</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">session</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">session</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">seqno</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">seqno</span><span class="p">;</span>

        <span class="n">record</span><span class="p">.</span><span class="n">headers</span><span class="p">()</span> <span class="o">=</span> <span class="p">{</span>

            <span class="p">{</span> <span class="s">&quot;session&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="n">session</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">session</span><span class="p">.</span><span class="n">size</span><span class="p">()}</span> <span class="p">},</span>

            <span class="p">{</span> <span class="s">&quot;seqno&quot;</span><span class="p">,</span>   <span class="p">{</span> <span class="o">&amp;</span><span class="n">seqno</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">seqno</span><span class="p">)}</span> <span class="p">}</span>

        <span class="p">};</span>



        <span class="n">record</span><span class="p">.</span><span class="n">setKey</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">key</span><span class="p">);</span>

        <span class="n">record</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>



        <span class="n">producer</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">record</span><span class="p">,</span>

                      <span class="c1">// Ack callback</span>

                      <span class="p">[</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">](</span><span class="k">const</span> <span class="n">kafka</span><span class="o">::</span><span class="n">Producer</span><span class="o">::</span><span class="n">RecordMetadata</span><span class="o">&amp;</span> <span class="n">metadata</span><span class="p">,</span> <span class="p">,</span> <span class="k">const</span> <span class="n">kafka</span><span class="o">::</span><span class="n">Error</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>

                           <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>  <span class="p">{</span>

                               <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;% Message delivery failed: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">error</span><span class="p">.</span><span class="n">message</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

                           <span class="p">}</span>

                       <span class="p">});</span>

    <span class="p">}</span>
</pre></div>

<h2 id="error-handling"><a class="toclink" href="#error-handling">Error handling</a></h2>
<p><code>Error</code> might occur at different places while sending a message,</p>
<ol>
<li>
<p>A <code>KafkaException</code> would be triggered if <code>KafkaProducer</code> failed to trigger the send operation.</p>
</li>
<li>
<p>Delivery <code>Error</code> would be passed through the delivery-callback.</p>
</li>
</ol>
<p>About <code>Error</code>'s <code>value()</code>s, there are 2 cases</p>
<ol>
<li>
<p>Local errors,</p>
<ul>
<li>
<p><code>RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC</code>      -- The topic doesn't exist</p>
</li>
<li>
<p><code>RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION</code>  -- The partition doesn't exist</p>
</li>
<li>
<p><code>RD_KAFKA_RESP_ERR__INVALID_ARG</code>        -- Invalid topic (topic is null or the length is too long (&gt;512))</p>
</li>
<li>
<p><code>RD_KAFKA_RESP_ERR__MSG_TIMED_OUT</code>      -- No ack received within the time limit</p>
</li>
</ul>
</li>
<li>
<p>Broker errors,</p>
<ul>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-ErrorCodes">Error Codes</a></li>
</ul>
</li>
</ol>
<h2 id="frequently-asked-questions"><a class="toclink" href="#frequently-asked-questions">Frequently Asked Questions</a></h2>
<h3 id="what-are-the-available-configurations"><a class="toclink" href="#what-are-the-available-configurations">What are the available configurations?</a></h3>
<ul>
<li>
<p><a href="KafkaClientConfiguration.md#kafkaproducer-configuration">KafkaProducerConfiguration</a></p>
</li>
<li>
<p><a href="../doxygen/classKAFKA__CPP__APIS__NAMESPACE_1_1ProducerConfig.html">Inline doxygen page</a></p>
</li>
</ul>
<h3 id="about-the-automatic-topic-creation"><a class="toclink" href="#about-the-automatic-topic-creation">About the automatic <code>topic creation</code></a></h3>
<p>If the cluster's configuration is with <code>auto.create.topics.enable=true</code>, the producer/consumer could trigger the brokers to create a new topic (with <code>send</code>, <code>subscribe</code>, etc)</p>
<p>Note, the default created topic may be not what you want (e.g, with <code>default.replication.factor=1</code> configuration as default, etc), thus causing other unexpected problems.</p>
<h3 id="how-to-enhance-the-sending-performance"><a class="toclink" href="#how-to-enhance-the-sending-performance">How to enhance the sending performance?</a></h3>
<p>Enlarging the default <code>BATCH_NUM_MESSAGES</code> and <code>LINGER_MS</code> might improve message batching, thus enhancing the throughput.</p>
<p>While, on the other hand, <code>LINGER_MS</code> would highly impact the latency.</p>
<p>The <code>QUEUE_BUFFERING_MAX_MESSAGES</code> and <code>QUEUE_BUFFERING_MAX_KBYTES</code> would determine the <code>max in flight requests (some materials about Kafka would call it in this way)</code>. If the queue buffer is full, the <code>send</code> operation would be blocked.</p>
<p>Larger <code>QUEUE_BUFFERING_MAX_MESSAGES</code>/<code>QUEUE_BUFFERING_MAX_KBYTES</code> might help to improve throughput as well, while also means more messages locally buffering.</p>
<h3 id="how-to-achieve-reliable-delivery"><a class="toclink" href="#how-to-achieve-reliable-delivery">How to achieve reliable delivery</a></h3>
<ul>
<li>
<p>Quick Answer,</p>
<ol>
<li>
<p>The Kafka cluster should be configured with <code>min.insync.replicas = 2</code> at least</p>
</li>
<li>
<p>Configure the <code>KafkaProducer</code> with property <code>{ProducerConfig::ENABLE_IDEMPOTENCE, "true"}</code>, together with proper error-handling (within the delivery callback).</p>
</li>
</ol>
</li>
<li>
<p>Complete Answer,</p>
<ul>
<li><a href="HowToMakeKafkaProducerReliable.md">How to Make KafkaProducer Reliable</a></li>
</ul>
</li>
</ul>
<h3 id="how-many-threads-would-be-created-by-a-kafkaproducer"><a class="toclink" href="#how-many-threads-would-be-created-by-a-kafkaproducer">How many threads would be created by a KafkaProducer?</a></h3>
<p>Excluding the user's main thread, <code>KafkaProducer</code> would start (N + 3) background threads. (N means the number of BOOTSTRAP_SERVERS)</p>
<p>Most of these background threads are started internally by librdkafka.</p>
<p>Here is a brief introduction what they're used for,</p>
<ol>
<li>
<p>Each broker (in the list of BOOTSTRAP_SERVERS) would take a separate thread to transmit messages towards a kafka cluster server.</p>
</li>
<li>
<p>Another 2 background threads would handle internal operations and kinds of timers, etc.</p>
</li>
<li>
<p>One more background thread to keep polling the delivery callback event.</p>
</li>
</ol>
<p>E.g, if a <code>KafkaProducer</code> was created with property of <code>BOOTSTRAP_SERVERS=127.0.0.1:8888,127.0.0.1:8889,127.0.0.1:8890</code>, it would take 7 threads in total (including the main thread).</p>
<h3 id="which-one-of-these-threads-will-handle-the-callbacks"><a class="toclink" href="#which-one-of-these-threads-will-handle-the-callbacks">Which one of these threads will handle the callbacks</a></h3>
<p>It will be handled by a background thread, not by the user's thread.</p>
<p>Note, should be careful if both the <code>KafkaProducer::send()</code> and the <code>producer::Callback</code> might access the same container at the same time.</p>
      <hr/>
      <footer class="text-center text-muted">
        Generated: 2022. 03. 01
      </footer>
      <hr/>
    </div>
  </body>
</html>